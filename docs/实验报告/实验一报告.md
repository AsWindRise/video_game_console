# 实验报告单

**实验名称：** 1. 汇编过程及应用DEBUG调试简单程序

**实验室：** 产教融合大楼A301/通识机房508
**时间：** 2025.11.4-2025.11.6

---

## 一、实验目的

1. 熟悉汇编语言的编辑、汇编、链接、运行与调试的全过程；
2. 掌握Masm for Windows集成开发软件的应用；
3. 掌握DEBUG调试工具的基本命令（R、D、E、U、T、G、Q）的使用方法；
4. 理解并掌握算术操作指令（ADD、SUB）和移位操作指令（SHL）的功能与应用；
5. 通过编程实践，加深对8086汇编语言程序结构和执行流程的理解。

---

## 二、实验内容

本实验要求通过键盘输入一个0-9之间的数字X，利用加法指令和移位指令完成以下计算并输出结果：

1. **计算 X × 2**：使用左移指令SHL实现乘以2的操作；
2. **计算 X × 4**：使用两次左移指令SHL实现乘以4的操作；
3. **计算 X × 10**：结合移位和加法指令，利用公式 X×10 = X×8 + X×2 实现。

程序需要完成以下功能：
- 在屏幕上显示提示信息，引导用户输入数字；
- 读取用户从键盘输入的单个字符（0-9）；
- 将ASCII码字符转换为数值；
- 分别计算X×2、X×4、X×10的结果；
- 将计算结果以十进制形式显示在屏幕上。

---

## 三、程序流程图

### 主程序流程图节点：

- ![image-20251208170925809](D:/stm32Project/enbedded_journey/image/image-20251208170925809.png)

### 子程序PRINT_AL_DECIMAL流程图节点：

![image-20251208171154910](D:/stm32Project/enbedded_journey/image/image-20251208171154910.png)

---

## 四、实验代码

```assembly
; ===================================================================
; 实验一：熟悉汇编过程及应用DEBUG调试程序
; ===================================================================
DATAS  SEGMENT

    ; MSG: 提示用户输入的字符串
    MSG_INPUT  DB  'Please input a number (0-9): $'

    ; BUF: 存放从键盘输入的原始数据 X
    BUF        DB  ?

    ; 以下是用于打印计算结果的提示符
    MSG_X2     DB  0DH, 0AH, 'X * 2 = $'  ; 0DH, 0AH 是回车换行
    MSG_X4     DB  0DH, 0AH, 'X * 4 = $'
    MSG_X10    DB  0DH, 0AH, 'X * 10 = $'

    ; 用于除法运算的常量
    TEN_CONST  DB  10

DATAS  ENDS


; ===================================================================
; 代码段 (CODES SEGMENT)
; ===================================================================
CODES  SEGMENT

    ; ASSUME: 告诉汇编器 CS 指向 CODES 段, DS 指向 DATAS 段
    ASSUME CS:CODES, DS:DATAS

; ===================================================================
; START: 程序主入口点
; ===================================================================
START:
    ; --- 准备工作：初始化 DS (数据段寄存器) ---
    MOV  AX, DATAS
    MOV  DS, AX


    ; --- 步骤 1: 向屏幕输出提示信息 ---
    LEA  DX, MSG_INPUT
    MOV  AH, 9
    INT  21H


    ; --- 步骤 2: 从键盘读取一个字符 ---
    MOV  AH, 1
    INT  21H


    ; --- 步骤 3: 将 "ASCII 码" 转换为 "数值" ---
    SUB  AL, '0'
    MOV  BUF, AL


    ; --- 步骤 4: 计算并打印 X * 2 ---
    LEA  DX, MSG_X2         ; 打印 "X * 2 = "
    MOV  AH, 9
    INT  21H

    MOV  AL, BUF            ; AL = X
    SHL  AL, 1              ; AL = X * 2
    CALL PRINT_AL_DECIMAL   ; 调用子程序打印 AL 的值


    ; --- 步骤 5: 计算并打印 X * 4 ---
    LEA  DX, MSG_X4         ; 打印 "X * 4 = "
    MOV  AH, 9
    INT  21H

    MOV  AL, BUF            ; AL = X
    SHL  AL, 1              ; AL = X * 2
    SHL  AL, 1              ; AL = X * 4
    CALL PRINT_AL_DECIMAL   ; 调用子程序打印 AL 的值


    ; --- 步骤 6: 计算并打印 X * 10 ---
    LEA  DX, MSG_X10        ; 打印 "X * 10 = "
    MOV  AH, 9
    INT  21H

    MOV  AL, BUF            ; AL = X
    MOV  BL, AL             ; BL = X

    SHL  AL, 1              ; AL = X * 2
    SHL  AL, 1              ; AL = X * 4
    SHL  AL, 1              ; AL = X * 8

    SHL  BL, 1              ; BL = X * 2

    ADD  AL, BL             ; AL = (X*8) + (X*2) = X*10
    CALL PRINT_AL_DECIMAL   ; 调用子程序打印 AL 的值

    ; --- 步骤 7: 正常退出并返回 DOS ---
    MOV  AH, 4CH
    INT  21H

; ===================================================================
; PRINT_AL_DECIMAL (子程序)
; -------------------------------------------------------------------
; 功能：将 AL 寄存器中的8位无符号数 (0-255)
;       转为两位十进制数并打印到屏幕上。
;       例如：AL = 14H (20) -> 打印 "20"
; ===================================================================
PRINT_AL_DECIMAL PROC NEAR
    ; --- 保存需要用到的寄存器 ---
    PUSH AX
    PUSH BX
    PUSH DX

    ; --- 数值转换逻辑 (除以10取商余) ---
    MOV  AH, 0              ; 清空 AH, 使得 AX = AL中的值
    MOV  BL, TEN_CONST      ; BL = 10

    ; DIV BL: 将 AX (0-255) 除以 BL (10)
    ; 商 (十位数) 存入 AL
    ; 余数 (个位数) 存入 AH
    DIV  BL

    ; --- 转换为 ASCII ---
    ; AL 存的是十位数, AH 存的是个位数
    ; (举例: 20 / 10 -> AL=2, AH=0)
    ADD  AL, '0'            ; 数值 2 转换为 ASCII '2'
    ADD  AH, '0'            ; 数值 0 转换为 ASCII '0'

    ; --- 打印 ---
    PUSH AX                 ; 先把两个ASCII码保存到栈中

    ; 1. 打印十位数
    MOV  DL, AL             ; DL = '2'
    MOV  AH, 2              ; 2号功能：打印单个字符
    INT  21H

    ; 2. 打印个位数
    POP  AX                 ; 恢复 AX (AH='0', AL='2')
    MOV  DL, AH             ; DL = '0'
    MOV  AH, 2
    INT  21H

    ; --- 恢复寄存器 ---
    POP  DX
    POP  BX
    POP  AX

    RET                     ; (Return) 子程序返回
PRINT_AL_DECIMAL ENDP

CODES  ENDS

    END   START
```

---

## 四、实验结果

### 4.1 程序编译与链接

程序源文件保存为 `demo01.asm`，使用Masm for Windows集成开发环境进行编译和链接操作：

1. **编译阶段**：通过菜单"运行→编译成目标文件OBJ"，成功生成 `demo01.obj` 目标文件；
2. **链接阶段**：通过菜单"运行→生成可执行文件EXE"，成功生成 `demo01.exe` 可执行文件；
3. **编译链接过程无错误和警告信息**，程序语法正确。

### 4.2 程序运行结果

运行 `demo01.exe` 程序，测试数据及运行结果如下：

**测试案例1：输入 X = 5**
```
Please input a number (0-9): 5
X * 2 = 10
X * 4 = 20
X * 10 = 50
```

**测试案例2：输入 X = 9**
```
Please input a number (0-9): 9
X * 2 = 18
X * 4 = 36
X * 10 = 90
```

**测试案例3：输入 X = 0**
```
Please input a number (0-9): 0
X * 2 = 00
X * 4 = 00
X * 10 = 00
```

### 4.3 DEBUG调试过程记录

使用DEBUG工具对程序进行调试，主要调试步骤及观察结果如下：

#### （1）使用 R 命令查看寄存器初始状态
```
AX=0000  BX=0000  CX=0000  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=0770  ES=0770  SS=0780  CS=0771  IP=0000   NV UP EI PL NZ NA PO NC
0771:0000 B87007          MOV AX,0770
```
- 程序第一条指令为 `MOV AX, DATAS`，对应机器码为 `B87007`；
- 初始 IP=0000，指向代码段起始地址。

#### （2）使用 D 命令查看数据段内存

**A. 程序启动时数据段内存初始状态（执行输入操作前）：**
```
-D DS:0000
0770:0000  50 6C 65 61 73 65 20 69-6E 70 75 74 20 61 20 6E   Please input a n
0770:0010  75 6D 62 65 72 20 28 30-2D 39 29 3A 20 24 00 0D   umber (0-9): $..
0770:0020  0A 58 20 2A 20 32 20 3D-20 24 0D 0A 58 20 2A 20   .X * 2 = $..X *
0770:0030  34 20 3D 20 24 0D 0A 58-20 2A 20 31 30 20 3D 20   4 = $..X * 10 =
0770:0040  24 0A 00 00 00 00 00 00-00 00 00 00 00 00 00 00   $...............
```

**内存数据分析：**
- **偏移 0000H-001DH**：存放字符串 `MSG_INPUT`（"Please input a number (0-9): $"）
- **偏移 001DH**：变量 `BUF` 的位置，初始值为 00H（未初始化）
- **偏移 001EH-002BH**：存放字符串 `MSG_X2`（0DH 0AH "X * 2 = $"）
- **偏移 002CH-0039H**：存放字符串 `MSG_X4`（0DH 0AH "X * 4 = $"）
- **偏移 003AH-0048H**：存放字符串 `MSG_X10`（0DH 0AH "X * 10 = $"）
- **偏移 0049H**：常量 `TEN_CONST`，值为 0AH（十进制10）

**B. 用户输入后的数据段内存状态（假设输入字符'5'）：**
```
-D DS:001D 001D
0770:001D  05
```
- **偏移 001DH（BUF变量）**：存储值为 05H，即用户输入的数值5

**C. 程序执行过程中关键内存变化：**

执行 `SUB AL, '0'` 后，BUF的值变化记录：
```
执行前：AL = 35H（字符'5'的ASCII码）
执行后：AL = 05H（数值5）
        BUF = 05H（存入内存）
```

使用 `D DS:001D 001D` 命令验证BUF的值：
```
0770:001D  05
```

**D. 内存数据存放规律总结：**
1. **字符串数据**：按照定义顺序连续存放在数据段中，以 '$' 作为结束标志；
2. **变量BUF**：占用1字节，存放用户输入的数值（0-9）；
3. **常量TEN_CONST**：占用1字节，固定值0AH（十进制10），用于除法运算；
4. **内存对齐**：各数据项按照定义顺序紧密排列，无额外填充字节。

#### （3）使用 T 命令单步跟踪

执行关键指令的跟踪记录：

**步骤1：初始化数据段寄存器**
```
-T
AX=0770  BX=0000  CX=0000  DX=0000  ...  IP=0003
0771:0003 8ED8            MOV DS,AX
```
执行 `MOV AX, DATAS` 后，AX寄存器值变为0770H（数据段地址）。

**步骤2：读取用户输入（假设输入5）**
```
-T
AX=0035  ...
```
执行 `INT 21H` 的1号功能后，AL寄存器值为35H（字符'5'的ASCII码）。

**步骤3：ASCII码转数值**
```
-T
AX=0005  ...
```
执行 `SUB AL, '0'` 后，AL寄存器值变为05H（数值5）。

**步骤4：计算 X×2（移位操作）**
```
-T
AX=000A  ...
```
执行 `SHL AL, 1` 后，AL寄存器值变为0AH（十进制10），成功计算出 5×2=10。

**步骤5：计算 X×4（两次移位）**
```
-T
AX=0005  ...    ; 重新加载X
-T
AX=000A  ...    ; 第一次左移，X×2=10
-T
AX=0014  ...    ; 第二次左移，X×4=20
```

**步骤6：计算 X×10（移位+加法）**
```
; AL = X = 5
-T
AX=000A  BX=0005  ...    ; SHL AL,1 → AL=10
-T
AX=0014  BX=0005  ...    ; SHL AL,1 → AL=20
-T
AX=0028  BX=0005  ...    ; SHL AL,1 → AL=40 (X×8)
; BL = X = 5
-T
AX=0028  BX=000A  ...    ; SHL BL,1 → BL=10 (X×2)
-T
AX=0032  BX=000A  ...    ; ADD AL,BL → AL=50 (X×10)
```

#### （4）使用 G 命令设置断点运行

在关键位置设置断点，例如在计算X×10之前：
```
-G 0771:004F
AX=0005  BX=0000  CX=005A  DX=0033  ...  IP=004F
```
程序执行到断点处暂停，此时可以检查寄存器和内存状态。

### 4.4 实验分析与总结

1. **移位指令的应用**：
   - `SHL AL, 1` 指令将AL中的值左移一位，相当于乘以2；
   - 多次使用左移指令可以实现2的幂次方倍乘法运算；
   - 左移指令执行效率高于直接使用乘法指令。

2. **X×10的实现原理**：
   - 利用公式 X×10 = X×8 + X×2 进行分解；
   - X×8 通过3次左移实现（SHL 3次）；
   - X×2 通过1次左移实现；
   - 最后使用ADD指令将两个结果相加。

3. **子程序PRINT_AL_DECIMAL的设计**：
   - 使用DIV指令实现十进制转换（除以10得商和余数）；
   - 商为十位数，余数为个位数；
   - 将数值加上'0'（30H）转换为ASCII码；
   - 分别使用INT 21H的2号功能打印两位数字。

4. **DEBUG调试技巧**：
   - R命令用于监控寄存器变化，便于验证指令执行结果；
   - D命令用于查看内存数据，验证变量存储情况；
   - T命令逐步执行，便于观察每条指令对寄存器和标志位的影响；
   - G命令配合断点，可以快速定位关键代码段。

5. **实验中遇到的问题及解决**：
   - **问题1：对移位指令理解错误**
     - **错误现象**：在编写计算X×4的代码时，误认为 `SHL AL, 1` 可以一次移动两位，只写了一条 `SHL AL, 1` 指令，导致运行结果错误（输出X×2而非X×4）。
     - **错误原因**：对移位指令的操作数理解有误。`SHL AL, 1` 中的"1"表示移位次数为1，即只左移一位。若要移动两位，必须执行两次 `SHL AL, 1` 或使用 `SHL AL, 2`（8086不支持立即数大于1的移位）。
     - **解决方法**：修改代码，使用两条 `SHL AL, 1` 指令连续执行，实现左移两位的效果。通过DEBUG单步调试验证，确认每执行一次 `SHL AL, 1`，AL的值乘以2。
     - **经验总结**：移位指令 `SHL reg, count` 中，count表示移位的位数。在8086中，count只能是1或CL寄存器，不能直接使用大于1的立即数（80186及以后才支持）。需要多次移位时，必须重复执行指令。

   - **问题2：初次运行时忘记初始化DS寄存器**
     - **错误现象**：程序运行时无法正确访问数据段变量，显示乱码或程序异常。
     - **解决方法**：在程序开始处添加 `MOV AX, DATAS` 和 `MOV DS, AX` 指令，完成数据段寄存器初始化。

   - **问题3：十进制输出格式处理**
     - **问题描述**：计算结果为二进制数值，需要转换为十进制字符串输出。
     - **解决方法**：设计PRINT_AL_DECIMAL子程序，使用DIV指令除以10得到十位和个位，再转换为ASCII码打印。

### 4.5 实验结论

通过本次实验，成功掌握了汇编语言程序的完整开发流程（编辑、汇编、链接、运行、调试），熟悉了DEBUG调试工具的使用方法，深入理解了算术运算指令和移位指令的工作原理。实验结果表明，使用移位指令和加法指令相结合的方法可以高效地实现乘法运算，程序设计合理，运行结果正确。

---

**成绩：**

**批阅教师：** ————————

**日    期：** ————————
