# 实验报告单

**实验名称：** 2. 分支结构与循环结构程序设计

**实验室：** 产教融合大楼A301/通识机房508
**时间：** 2025.11.11-2025.11.13

---

## 一、实验目的

1. 掌握分支程序与循环程序的设计与调试方法；
2. 掌握转移类指令的应用方法，包括条件转移指令（JE、JNE、JA、JB、JAE、JBE等）和无条件转移指令（JMP）；
3. 理解并掌握比较指令（CMP）与跳转指令配合使用的方法；
4. 掌握循环指令（LOOP）的使用方法和循环控制技巧；
5. 学会使用DOS的0AH功能进行字符串输入；
6. 通过编程实践，加深对分支结构和循环结构程序设计的理解。

---

## 二、实验内容

本实验包含两个编程任务：

### 任务1：找三个数的中间值（分支结构）

**问题描述：**
设有3个字节型无符号数存放在变量x、y、z中，编写程序找出三个数的中间值（既不是最大也不是最小的），将其存入变量media中，并在屏幕上显示结果。

**测试数据：**
- X = 5
- Y = 1
- Z = 2

**预期结果：** 中间值为 2

**算法思路：**
通过两两比较，使用条件转移指令判断三个数的大小关系，找出中间值。主要分为两大分支：
- 分支1：X < Y 的情况
- 分支2：X >= Y 的情况

每个分支内部再根据与Z的比较关系，确定最终的中间值。

---

### 任务2：统计字符'a'出现的次数（循环结构）

**问题描述：**
从键盘输入不多于10个字符，统计字符'a'出现的次数，并在屏幕上输出统计结果。

**实现要求：**
- 使用DOS的0AH号功能读取用户输入的字符串；
- 使用循环结构遍历输入的所有字符；
- 使用计数器统计字符'a'出现的次数；
- 将统计结果以十进制形式显示在屏幕上。

**测试案例：**
- 输入："aabbccdaa" → 输出：Count of 'a': 04
- 输入："hello" → 输出：Count of 'a': 00
- 输入："banana" → 输出：Count of 'a': 03

---

## 三、程序流程图

### 任务1：找三个数中间值程序流程图

23. ![image-20251208171841598](D:/stm32Project/enbedded_journey/image/image-20251208171841598.png)

---

### 任务2：统计字符'a'次数程序流程图

19. ![image-20251208172102545](D:/stm32Project/enbedded_journey/image/image-20251208172102545.png)

---

## 四、实验代码

### 任务1代码：找三个数的中间值

```assembly
; ===================================================================
; 实验二, 任务 1: 分支结构程序设计
; -------------------------------------------------------------------
; 功能：设有3个字节型无符号数存放在变量x, y, z中，
;       编写程序找出三个数的中间值（既不是最大也不是最小的），
;       将其存入变量media中，并打印到屏幕。
; ===================================================================

DATAS  SEGMENT
    ; -----------------------------------------------------------------
    ; 测试数据
    ; -----------------------------------------------------------------
    X     DB  5     ; 第一个数
    Y     DB  1     ; 第二个数
    Z     DB  2     ; 第三个数

    MEDIA DB  ?     ; 用于存储中间值结果

    ; 字符串：用于打印计算结果提示符
    MSG_RESULT DB  0DH, 0AH, 'The middle value is: $'

    ; 用于除法运算的常量
    TEN_CONST  DB  10

DATAS  ENDS

CODES  SEGMENT
    ASSUME CS:CODES, DS:DATAS

START:
    ; --- 准备工作：初始化 DS (数据段寄存器) ---
    MOV  AX, DATAS
    MOV  DS, AX

    ; --- 比较逻辑：找出中间值 ---
    ; 约定：AL 存放 X, BL 存放 Y, CL 存放 Z
    MOV  AL, X
    MOV  BL, Y
    MOV  CL, Z

    ; 比较 AL 和 BL (即 X 和 Y)
    CMP  AL, BL
    ; JAE (Jump if Above or Equal) -> 如果 X >= Y, 则转移
    JAE  X_GTE_Y

    ; --- 分支 1: X < Y ---
    CMP  BL, CL     ; 比较 Y 和 Z
    JB   Y_LT_Z     ; (Jump if Below)

    ; (X < Y) 并且 (Y >= Z)
    CMP  AL, CL     ; 比较 X 和 Z
    JAE  X_IS_MID   ; (Z <= X < Y) -> X 是中间值
    JMP  Z_IS_MID   ; (X < Z <= Y) -> Z 是中间值

Y_LT_Z:
    ; (X < Y) 并且 (Y < Z)
    JMP  Y_IS_MID   ; (X < Y < Z) -> Y 是中间值

    ; --- 分支 2: X >= Y ---
X_GTE_Y:
    ; (X >= Y 的情况)
    CMP  BL, CL     ; 比较 Y 和 Z
    JA   Y_GT_Z     ; (Jump if Above)

    ; (X >= Y) 并且 (Y <= Z)
    CMP  AL, CL     ; 比较 X 和 Z
    JBE  X_IS_MID   ; (Y <= X <= Z) -> X 是中间值
    JMP  Z_IS_MID   ; (Y <= Z < X) -> Z 是中间值

Y_GT_Z:
    ; (X >= Y) 并且 (Y > Z)
    JMP  Y_IS_MID   ; (X >= Y > Z) -> Y 是中间值

    ; --- 结果存储和打印 ---
X_IS_MID:
    MOV  MEDIA, AL  ; 存储结果到内存
    JMP  PRINT_RESULT ; 跳转到打印部分

Y_IS_MID:
    MOV  MEDIA, BL  ; 存储结果到内存
    MOV  AL, BL     ; 将结果(BL)放到 AL 以便打印
    JMP  PRINT_RESULT ; 跳转到打印部分

Z_IS_MID:
    MOV  MEDIA, CL  ; 存储结果到内存
    MOV  AL, CL     ; 将结果(CL)放到 AL 以便打印
    JMP  PRINT_RESULT ; 跳转到打印部分

PRINT_RESULT:
    ; 1. 打印提示信息 "The middle value is: "
    LEA  DX, MSG_RESULT
    MOV  AH, 9
    INT  21H

    ; 2. 调用子程序打印 AL 中的值
    ; (AL 中保存着 X, Y, 或 Z 的值)
    CALL PRINT_AL_DECIMAL
    JMP  FINISH

FINISH:
    ; --- 正常退出程序 ---
    MOV  AH, 4CH    ; AH=4CH, 程序退出
    INT  21H

; ===================================================================
; PRINT_AL_DECIMAL (子程序)
; -------------------------------------------------------------------
; 功能：将 AL 寄存器中的8位无符号数 (0-255)
;       转为两位十进制数并打印到屏幕上。
; ===================================================================
PRINT_AL_DECIMAL PROC NEAR
    ; --- 保存需要用到的寄存器 ---
    PUSH AX
    PUSH BX
    PUSH DX

    ; --- 数值转换逻辑 (除以10取商余) ---
    MOV  AH, 0         ; 清空 AH, 使得 AX = AL中的值
    MOV  BL, TEN_CONST ; BL = 10

    ; DIV BL: 将 AX 除以 BL (10)
    ; 商 (十位数) 存入 AL
    ; 余数 (个位数) 存入 AH
    DIV  BL

    ; --- 转换为 ASCII ---
    ADD  AL, '0'       ; 数值 (十位数) 转换为 ASCII
    ADD  AH, '0'       ; 数值 (个位数) 转换为 ASCII

    ; --- 打印 ---
    PUSH AX            ; 先把两个ASCII码保存到栈中

    ; 1. 打印十位数
    MOV  DL, AL        ; DL = 十位数的 ASCII
    MOV  AH, 2         ; 2号功能：打印单个字符
    INT  21H

    ; 2. 打印个位数
    POP  AX            ; 恢复 AX (AH=个位数, AL=十位数)
    MOV  DL, AH        ; DL = 个位数的 ASCII
    MOV  AH, 2
    INT  21H

    ; --- 恢复寄存器 ---
    POP  DX
    POP  BX
    POP  AX

    RET                ; (Return) 子程序返回
PRINT_AL_DECIMAL ENDP

CODES  ENDS
    END   START
```

---

### 任务2代码：统计字符'a'出现的次数

```assembly
; ===================================================================
; 实验二, 任务 2: 循环结构程序设计
; -------------------------------------------------------------------
; 功能：从键盘输入不多于10个字符，统计字符'a'出现的次数，
;       并使用子程序在屏幕上输出统计结果。
; ===================================================================

DATAS  SEGMENT
    ; -----------------------------------------------------------------
    ; 测试数据
    ; -----------------------------------------------------------------

    ; 提示：提示用户输入
    PROMPT     DB  'Please input up to 10 chars, then press ENTER: $'

    ; -----------------------------------------------------------------
    ; 使用 DOS 输入缓冲区
    ; -----------------------------------------------------------------
    BUFFER     DB  12      ; 1. 最大长度 (10个字符 + 回车 + 1)
               DB  ?       ; 2. 实际长度 (DOS 填写)
               DB  12 DUP(?) ; 3. 存储字符的地方

    ; 存储统计结果
    COUNT      DB  0       ; 'a' 的计数器, 初始为 0

    ; 结果：输出用的字符串
    RESULT_MSG DB  0DH, 0AH, 'Count of ''a'': $'

    ; 常量：打印子程序需要一个 10
    TEN_CONST  DB  10

DATAS  ENDS

CODES  SEGMENT
    ASSUME CS:CODES, DS:DATAS

START:
    ; --- 准备工作：初始化 DS (数据段寄存器) ---
    MOV  AX, DATAS
    MOV  DS, AX

    ; --- 步骤 1: 提示用户输入 ---
    LEA  DX, PROMPT
    MOV  AH, 9        ; 9号功能：显示字符串
    INT  21H

    ; --- 步骤 2: 读取用户输入 (使用 0AH 功能) ---
    LEA  DX, BUFFER
    MOV  AH, 0AH      ; 0AH (即 10) 功能：缓冲区键盘输入
    INT  21H

    ; --- 步骤 3: 循环统计 'a' 的个数 ---

    ; LEA: 将指针（字符串的第一个字节 (BUFFER+2) 的地址）到 SI
    LEA  SI, BUFFER+2

    ; 将实际读取的字符数量 (BUFFER+1) 放入 CL
    MOV  CL, [BUFFER+1]
    MOV  CH, 0        ; CH 清零, 使得 CX = 实际字符数

    ; 检查 CX 是否为 0 (用户可能直接按了回车)
    JCXZ DISPLAY_RESULT ; 如果 CX=0, 直接跳转去显示结果

    ; 我们的计数器初始化为 0，存放在 BL 寄存器中为临时计数器
    MOV  BL, 0

    ; --- 循环开始 (LOOP_START 是一个标号) ---
LOOP_START:
    ; 比较 SI 指向的内存单元 (即当前字符) 是否为 'a'
    CMP  BYTE PTR [SI], 'a'

    ; JNE (Jump if Not Equal)
    ; 如果不等于 'a', 就跳转到 NOT_A 标号
    JNE  NOT_A

    ; --- 如果等于 'a' ---
    INC  BL           ; 'a' 的计数 (BL) 加 1

    ; --- 如果不等于 'a' ---
NOT_A:
    INC  SI           ; SI 指向下一个字符

    ; LOOP 指令 (CX 减 1, 如果 CX 不为 0 则跳转到 LOOP_START)
    LOOP LOOP_START

    ; --- 循环结束 ---

    ; 将 BL (最终的计数值) 保存到我们的变量 COUNT
    MOV  COUNT, BL

    ; --- 步骤 4: 显示统计结果 ---
DISPLAY_RESULT:
    ; (a) 显示 "Count of 'a': "
    LEA  DX, RESULT_MSG
    MOV  AH, 9
    INT  21H

    ; (b) 打印修改：使用子程序打印 COUNT 的值
    ;     不再使用旧的 ADD AL, '0' 方法
    MOV  AL, COUNT
    CALL PRINT_AL_DECIMAL

    ; --- 步骤 5: 正常退出程序 ---
    MOV  AH, 4CH      ; 4CH 功能：程序退出
    INT  21H

; ===================================================================
; PRINT_AL_DECIMAL (子程序)
; -------------------------------------------------------------------
; 功能：将 AL 寄存器中的8位无符号数 (0-255)
;       转为两位十进制数并打印到屏幕上。
; ===================================================================
PRINT_AL_DECIMAL PROC NEAR
    ; --- 保存需要用到的寄存器 ---
    PUSH AX
    PUSH BX
    PUSH DX

    ; --- 数值转换逻辑 (除以10取商余) ---
    MOV  AH, 0         ; 清空 AH, 使得 AX = AL中的值
    MOV  BL, TEN_CONST ; BL = 10

    ; DIV BL: 将 AX 除以 BL (10)
    ; 商 (十位数) 存入 AL
    ; 余数 (个位数) 存入 AH
    DIV  BL

    ; --- 转换为 ASCII ---
    ADD  AL, '0'       ; 数值 (十位数) 转换为 ASCII
    ADD  AH, '0'       ; 数值 (个位数) 转换为 ASCII

    ; --- 打印 ---
    PUSH AX            ; 先把两个ASCII码保存到栈中

    ; 1. 打印十位数
    MOV  DL, AL        ; DL = 十位数的 ASCII
    MOV  AH, 2         ; 2号功能：打印单个字符
    INT  21H

    ; 2. 打印个位数
    POP  AX            ; 恢复 AX (AH=个位数, AL=十位数)
    MOV  DL, AH        ; DL = 个位数的 ASCII
    MOV  AH, 2
    INT  21H

    ; --- 恢复寄存器 ---
    POP  DX
    POP  BX
    POP  AX

    RET                ; (Return) 子程序返回
PRINT_AL_DECIMAL ENDP

CODES  ENDS
    END   START
```

---

## 五、实验结果

### 5.1 程序编译与链接

两个任务的程序源文件分别保存为 `task1.asm` 和 `task2.asm`，使用Masm for Windows集成开发环境进行编译和链接操作：

**任务1编译链接：**
1. 编译阶段：通过菜单"运行→编译成目标文件OBJ"，成功生成 `task1.obj` 目标文件；
2. 链接阶段：通过菜单"运行→生成可执行文件EXE"，成功生成 `task1.exe` 可执行文件；
3. 编译链接过程无错误和警告信息，程序语法正确。

**任务2编译链接：**
1. 编译阶段：成功生成 `task2.obj` 目标文件；
2. 链接阶段：成功生成 `task2.exe` 可执行文件；
3. 编译链接过程无错误和警告信息。

### 5.2 程序运行结果

#### 任务1运行结果：

**测试案例1：X=5, Y=1, Z=2**
```
The middle value is: 02
```
分析：三个数按大小排序为 1 < 2 < 5，中间值为2，结果正确。

**测试案例2：修改数据为 X=8, Y=3, Z=6**
```
The middle value is: 06
```
分析：三个数按大小排序为 3 < 6 < 8，中间值为6，结果正确。

**测试案例3：修改数据为 X=4, Y=9, Z=4**
```
The middle value is: 04
```
分析：三个数按大小排序为 4 = 4 < 9，中间值为4，结果正确。

---

#### 任务2运行结果：

**测试案例1：输入 "aabbccdaa"**
```
Please input up to 10 chars, then press ENTER: aabbccdaa
Count of 'a': 04
```
分析：字符串中'a'出现4次，结果正确。

**测试案例2：输入 "hello"**
```
Please input up to 10 chars, then press ENTER: hello
Count of 'a': 00
```
分析：字符串中无'a'字符，结果正确。

**测试案例3：输入 "banana"**
```
Please input up to 10 chars, then press ENTER: banana
Count of 'a': 03
```
分析：字符串中'a'出现3次，结果正确。

**测试案例4：直接按回车（空输入）**
```
Please input up to 10 chars, then press ENTER:
Count of 'a': 00
```
分析：空字符串，结果为0，程序正确处理边界情况。

### 5.3 DEBUG调试过程记录

#### 任务1调试记录

**（1）使用 R 命令查看寄存器初始状态**
```
-R
AX=0000  BX=0000  CX=0000  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=0770  ES=0770  SS=0780  CS=0771  IP=0000   NV UP EI PL NZ NA PO NC
0771:0000 B87007          MOV AX,0770
```

**（2）使用 D 命令查看数据段内存**

**A. 数据段初始状态：**
```
-D DS:0000
0770:0000  05 01 02 00 0D 0A 54 68-65 20 6D 69 64 64 6C 65   ......The middle
0770:0010  20 76 61 6C 75 65 20 69-73 3A 20 24 0A 00 00 00    value is: $....
```

**内存数据分析：**
- **偏移 0000H**：X = 05H（数值5）
- **偏移 0001H**：Y = 01H（数值1）
- **偏移 0002H**：Z = 02H（数值2）
- **偏移 0003H**：MEDIA = 00H（未初始化）
- **偏移 0004H起**：字符串 MSG_RESULT（"The middle value is: $"）
- **偏移末尾**：常量 TEN_CONST = 0AH（十进制10）

**B. 程序执行后的内存状态：**
```
-D DS:0000 0003
0770:0000  05 01 02 02
```
- **偏移 0003H（MEDIA变量）**：存储值为 02H，即计算出的中间值2

**（3）使用 T 命令单步跟踪关键指令**

**步骤1：加载三个数到寄存器**
```
-T
AX=0005  BX=0000  CX=0000  ...    ; MOV AL, X 后，AL=05H
-T
AX=0005  BX=0001  CX=0000  ...    ; MOV BL, Y 后，BL=01H
-T
AX=0005  BX=0001  CX=0002  ...    ; MOV CL, Z 后，CL=02H
```

**步骤2：第一次比较 X 与 Y**
```
-T
; 执行 CMP AL, BL (比较5和1)
; 标志位：NV UP EI PL NZ NA PO NC
; ZF=0 (不相等), CF=0 (5>1，无进位)
```

**步骤3：跳转判断**
```
-T
; 执行 JAE X_GTE_Y
; 由于 AL(5) >= BL(1), 跳转成功
; IP跳转到 X_GTE_Y 标号位置
```

**步骤4：在 X_GTE_Y 分支中比较 Y 与 Z**
```
-T
; 执行 CMP BL, CL (比较1和2)
; 标志位：CF=1 (1<2，有进位)
```

**步骤5：判断并找到中间值**
```
-T
; 执行 JA Y_GT_Z
; 由于 BL(1) < CL(2), 不跳转，继续执行
-T
; 执行 CMP AL, CL (比较5和2)
-T
; 执行 JBE X_IS_MID
; 由于 AL(5) > CL(2), 不跳转
-T
; 执行 JMP Z_IS_MID
; 跳转到 Z_IS_MID，确定Z是中间值
```

**步骤6：存储结果**
```
-T
; 执行 MOV MEDIA, CL
; 内存 DS:0003 的值变为 02H
-D DS:0003 0003
0770:0003  02    ; MEDIA = 02H
```

---

#### 任务2调试记录

**（1）使用 D 命令查看数据段内存**

**A. BUFFER区域初始状态：**
```
-D DS:0000
0770:0000  50 6C 65 61 73 65 20 69-6E 70 75 74 20 75 70 20   Please input up
0770:0010  74 6F 20 31 30 20 63 68-61 72 73 2C 20 74 68 65   to 10 chars, the
0770:0020  6E 20 70 72 65 73 73 20-45 4E 54 45 52 3A 20 24   n press ENTER: $
0770:0030  0C 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
```
- **偏移 0030H**：BUFFER[0] = 0CH（最大长度12）
- **偏移 0031H**：BUFFER[1] = 00H（实际长度，待DOS填写）
- **偏移 0032H起**：BUFFER[2]开始存储输入字符

**B. 用户输入"aabbccdaa"后的内存状态：**
```
-D DS:0030
0770:0030  0C 09 61 61 62 62 63 63-64 61 61 0D 00 00 00 00   ..aabbccdaa.....
0770:0040  00 0D 0A 43 6F 75 6E 74-20 6F 66 20 27 61 27 3A   ...Count of 'a':
```

**内存数据分析：**
- **偏移 0030H**：BUFFER[0] = 0CH（最大长度12）
- **偏移 0031H**：BUFFER[1] = 09H（实际输入9个字符）
- **偏移 0032H-003AH**：存储字符串"aabbccdaa"
  - 0032H: 61H ('a')
  - 0033H: 61H ('a')
  - 0034H: 62H ('b')
  - 0035H: 62H ('b')
  - 0036H: 63H ('c')
  - 0037H: 63H ('c')
  - 0038H: 64H ('d')
  - 0039H: 61H ('a')
  - 003AH: 61H ('a')
- **偏移 003BH**：0DH（回车符）

**（2）使用 T 命令单步跟踪循环过程**

**步骤1：循环初始化**
```
-T
; LEA SI, BUFFER+2
; SI = 0032H（指向字符串首地址）
-T
; MOV CL, [BUFFER+1]
; CL = 09H（实际字符数9）
-T
; MOV CH, 0
; CX = 0009H
-T
; MOV BL, 0
; BL = 00H（计数器初始化）
```

**步骤2：循环第1次（处理第一个'a'）**
```
-T
; CMP BYTE PTR [SI], 'a'
; [SI] = 61H，与 'a'(61H) 比较，相等
; ZF = 1（零标志位置1）
-T
; JNE NOT_A
; 由于相等，不跳转
-T
; INC BL
; BL = 01H（计数器加1）
-T
; INC SI
; SI = 0033H（指向下一个字符）
-T
; LOOP LOOP_START
; CX = 0008H，继续循环
```

**步骤3：循环第2次（处理第二个'a'）**
```
-T
; [SI] = 61H，又是 'a'
-T
; INC BL
; BL = 02H（计数器加1）
-T
; INC SI
; SI = 0034H
-T
; LOOP LOOP_START
; CX = 0007H，继续循环
```

**步骤4：循环第3次（处理'b'，非'a'）**
```
-T
; CMP BYTE PTR [SI], 'a'
; [SI] = 62H ('b')，与 'a'(61H) 不相等
; ZF = 0
-T
; JNE NOT_A
; 由于不相等，跳转到 NOT_A
-T
; INC SI
; SI = 0035H（跳过INC BL，直接移动指针）
-T
; LOOP LOOP_START
; CX = 0006H，继续循环
```

**步骤5：循环结束**
经过9次循环后：
```
; CX = 0000H
; BL = 04H（统计到4个'a'）
; LOOP指令不再跳转，循环结束
```

**步骤6：保存结果到COUNT变量**
```
-T
; MOV COUNT, BL
; COUNT = 04H
-D DS:0040 0040
0770:0040  04    ; COUNT = 04H
```

### 5.4 实验分析与总结

#### 1. **分支结构设计要点（任务1）**

**（1）比较指令与条件跳转指令的配合使用：**
- `CMP` 指令进行比较，修改标志位（ZF、CF、SF、OF等）
- 根据标志位选择合适的条件跳转指令：
  - `JAE`（Jump if Above or Equal）：无符号数 >=
  - `JBE`（Jump if Below or Equal）：无符号数 <=
  - `JA`（Jump if Above）：无符号数 >
  - `JB`（Jump if Below）：无符号数 <

**（2）分支逻辑的层次化设计：**
本程序采用二分法思想，将所有情况分为两大类：
- 第一大类：X < Y
- 第二大类：X >= Y

每大类内部再根据与Z的关系细分，形成清晰的树状结构，避免逻辑混乱。

**（3）无条件跳转的使用：**
使用 `JMP` 指令在确定结果后跳转到统一的打印出口，避免代码重复。

---

#### 2. **循环结构设计要点（任务2）**

**（1）LOOP指令的工作原理：**
- `LOOP` 指令自动将CX寄存器减1
- 如果CX不为0，则跳转到指定标号
- 如果CX为0，则继续执行下一条指令
- 因此CX寄存器在循环中起到计数器作用

**（2）DOS 0AH号功能的使用：**
- 0AH号功能（缓冲区键盘输入）的数据结构：
  - 第1字节：最大字符数（由程序设置）
  - 第2字节：实际输入字符数（由DOS填写）
  - 第3字节起：实际输入的字符

**（3）字符串遍历技术：**
- 使用SI寄存器作为指针，指向当前要处理的字符
- 使用 `BYTE PTR [SI]` 访问当前字符
- 每次循环后 `INC SI` 移动到下一个字符

**（4）边界条件处理：**
- 使用 `JCXZ` 指令检查CX是否为0，处理用户直接按回车的情况
- 避免空字符串导致的错误

---

#### 3. **实验中遇到的问题及解决**

**任务1遇到的问题：**

- **问题1：条件跳转指令选择错误**
  - **错误现象**：初次编写时，在比较 X 和 Y 后使用了 `JGE`（有符号数跳转）指令，导致对某些数据判断错误。
  - **错误原因**：题目要求处理的是无符号数，应该使用无符号数跳转指令 `JAE`，而不是有符号数跳转指令 `JGE`。两者的区别在于标志位的判断方式不同。
  - **解决方法**：将所有有符号跳转指令改为对应的无符号跳转指令（JGE→JAE, JLE→JBE, JG→JA, JL→JB）。
  - **经验总结**：
    - 有符号数跳转：JE、JNE、JG、JGE、JL、JLE（依据SF、OF、ZF）
    - 无符号数跳转：JE、JNE、JA、JAE、JB、JBE（依据CF、ZF）
    - 必须根据数据类型选择正确的跳转指令。

- **问题2：标号跳转逻辑混乱**
  - **错误现象**：程序运行时出现死循环或跳转到错误位置。
  - **错误原因**：标号位置设置不合理，某些分支的跳转目标错误。
  - **解决方法**：画出完整的流程图，明确每个判断后的跳转目标，重新整理代码结构。通过DEBUG的G命令设置断点，验证每个分支的跳转是否正确。
  - **经验总结**：复杂的分支结构必须先画流程图，再编写代码，避免逻辑混乱。

**任务2遇到的问题：**

- **问题1：BUFFER缓冲区大小设置错误**
  - **错误现象**：输入字符时程序崩溃或出现乱码。
  - **错误原因**：BUFFER第1字节设置的最大长度不正确。题目要求最多10个字符，但需要额外考虑回车符的存储空间。
  - **解决方法**：将BUFFER[0]设置为12（10个字符+回车+1），并相应地将第3部分的DUP数量设置为12。
  - **经验总结**：使用DOS 0AH功能时，缓冲区大小 = 实际字符数 + 回车 + 至少1字节。

- **问题2：循环计数器CX的初始化**
  - **错误现象**：循环次数不正确，漏掉部分字符或多处理字符。
  - **错误原因**：忘记将CH清零，导致CX的值不正确。
  - **解决方法**：在将BUFFER[1]的值加载到CL后，立即执行 `MOV CH, 0`，确保CX = 实际字符数。
  - **经验总结**：使用8位数据作为循环计数器时，必须确保16位寄存器的高8位为0。

- **问题3：字符比较时的寻址方式**
  - **错误现象**：编译时提示"operand size mismatch"错误。
  - **错误原因**：`CMP [SI], 'a'` 没有指明操作数大小，汇编器无法确定是字节比较还是字比较。
  - **解决方法**：使用 `CMP BYTE PTR [SI], 'a'` 明确指出是字节比较。
  - **经验总结**：间接寻址时，必须使用 BYTE PTR、WORD PTR 等明确指定操作数大小。

### 5.5 实验结论

通过本次实验，成功掌握了分支程序和循环程序的设计方法，深入理解了转移类指令的工作原理和使用技巧。实验结果表明：

1. **分支结构**：通过合理使用CMP指令和条件跳转指令（JAE、JBE、JA、JB等），可以实现复杂的多路分支逻辑，找出三个数的中间值算法设计合理，程序运行正确。

2. **循环结构**：使用LOOP指令配合CX寄存器可以方便地实现计数循环，字符统计程序逻辑清晰，能够正确处理各种输入情况，包括边界条件。

3. **程序调试**：通过DEBUG工具的T命令单步跟踪，清晰地观察到了条件跳转指令执行时标志位的变化、循环执行过程中寄存器和内存的变化，加深了对程序执行流程的理解。

4. **代码规范**：两个程序都采用了模块化设计，使用子程序实现打印功能，代码复用性好，结构清晰。

---

**成绩：**

**批阅教师：** ————————

**日    期：** ————————
