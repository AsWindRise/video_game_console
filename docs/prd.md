



# 🕹️ STM32F4 游戏机项目规划：HAL 巩固与组件设计





## 🎯 项目目标



| **类别**     | **目标说明**                                                 |
| ------------ | ------------------------------------------------------------ |
| **首要产物** | 基于 **STM32F4** 的多游戏平台。                              |
| **核心目的** | 巩固 **STM32 HAL 库基础**，掌握 **DMA、EXTI、Timer** 等高级应用。 |
| **方法论**   | 实践**非阻塞、解耦**原则，设计并实现**通用组件库**（菜单、输入、配置）。 |
| **产出物**   | 首要产物为自主编写的、可扩展的**多级菜单框架**和**游戏框架**。然后时存储系统、联网系统、蓝牙系统的搭建。 |

------

## 🛠️ 技术选型
【说明】需要明确各阶段使用的具体技术栈，建议包括：

- 使用裸机调度器
- 图形库u8g2
- SD卡文件系统（建议FatFs）
- flash GD25Q32
- TCP/IP协议栈待定
- 蓝牙模块HC02和SPP
- 其他关键第三方库

## 🎯 MVP定义 (最小可行产品)

**MVP = 阶段I + 阶段II**，目标是构建一个**能玩、能扩展、架构清晰**的游戏掌机原型。

### MVP范围

**包含阶段：**
- ✅ 阶段I：核心驱动与架构验证
- ✅ 阶段II：菜单框架与游戏扩展

**不包含阶段：**
- ❌ 阶段III：数据持久化（档案管理、存档、排行榜）
- ❌ 阶段IV：高级外设（RTC、计算器）
- ❌ 阶段V：网络与云同步
- ❌ 阶段VI：蓝牙联机

### 必须完成的核心功能 (P0)

| **序号** | **功能模块** | **具体要求** | **验收标准** |
|---------|------------|-------------|-------------|
| 1 | **输入抽象层** | 实现 `input_manager` 组件 | 能将按键和摇杆事件统一抽象为逻辑输入，应用层只能通过抽象接口获取输入 |
| 2 | **原型游戏** | 实现一个极简游戏（如5x5网格贪吃蛇） | 游戏能运行，响应输入，FPS > 20，代码遵循三层架构 |
| 3 | **菜单框架** | 实现多级菜单系统 | 支持主菜单→子菜单→游戏启动的完整流程，新增菜单项≤2个文件 |
| 4 | **游戏接入机制** | 将原型游戏重构并接入菜单 | 能从菜单启动游戏并返回菜单，游戏独立运行 |
| 5 | **游戏扩展** | 添加2-3个新游戏 | 至少3个可玩游戏，新增游戏≤3个文件，互不影响 |

### 重要但非必需功能 (P1)

| **序号** | **功能模块** | **具体要求** | **是否纳入MVP** |
|---------|------------|-------------|----------------|
| 6 | **虚拟键盘** | 支持字符输入 | ✅ 建议纳入（阶段II末尾实现） |
| 7 | **FPS计数器** | 性能监控工具 | ✅ 建议纳入（用于性能优化） |
| 8 | **DMA优化** | I2C显示传输优化 | ⚠️ 可选（如果FPS不足再做） |

### MVP验收标准

**功能性验收：**
- ✅ 能通过菜单选择并启动至少3个不同的游戏
- ✅ 每个游戏能正常运行、响应输入、显示画面
- ✅ 游戏能正常退出并返回菜单，无卡死现象
- ✅ 虚拟键盘能输入字母、数字（用于测试）

**架构性验收：**
- ✅ 应用层代码完全不依赖HAL层（无 `HAL_*` 函数调用）
- ✅ 新增菜单项修改≤2个文件
- ✅ 新增游戏修改≤3个文件
- ✅ 所有游戏逻辑只通过 `input_manager` 和 `u8g2` API

**性能性验收：**
- ✅ 菜单操作响应延迟 < 50ms
- ✅ 游戏运行帧率 > 20 FPS（目标30 FPS）
- ✅ 按键响应延迟 < 10ms

**代码质量验收：**
- ✅ 代码符合DRY原则（无明显重复代码）
- ✅ 代码符合KISS原则（逻辑清晰简单）
- ✅ 模块职责单一，符合SOLID原则

### MVP之后的扩展路径

**MVP完成后，按优先级依次实现：**

```
MVP (阶段I+II)
    ↓
【第一个里程碑！庆祝！】
    ↓
阶段III (P1重要) → 档案管理 + 存档 + 排行榜
    ↓
阶段IV (P2可选) → RTC时钟 + 计算器等工具
    ↓
阶段V (P3选做) → 网络功能
    ↓
阶段VI (P3选做) → 蓝牙联机
```

### MVP成功标志

**当满足以下条件时，MVP即宣告成功：**

1. ✅ 你能自豪地对朋友说："来，玩玩我做的掌机！"
2. ✅ 新增游戏时你只需要关注游戏逻辑，不需要改底层
3. ✅ 代码架构清晰，可以作为学习STM32的参考案例
4. ✅ 你掌握了事件驱动、分层解耦、组件化设计等核心思想

**MVP预期学习收益：**
- 📚 深入理解HAL库的外设使用（GPIO、ADC、I2C、Timer）
- 📚 掌握事件驱动和非阻塞编程模式
- 📚 学会设计可扩展的软件架构
- 📚 实践SOLID、DRY、KISS等设计原则
- 📚 积累嵌入式系统的性能优化经验

------

## 🗺️ 阶段划分与实施计划

| **阶段**                 | **模块**         | **预计实现的功能**                                           | **核心功能目标**                    | **优先级** |
| ------------------------ | ---------------- | ------------------------------------------------------------ | ----------------------------------- | ---------- |
| **I. 核心驱动与架构验证** | **输入驱动**     | 编写按键和摇杆（ADC/GPIO）的底层驱动（✅已完成）.             | 硬件 I/O 准备就绪.                  | **P0(核心)** |
|                          | **图形显示**     | 封装 OLED 底层驱动，并移植 u8g2 图形库（✅已完成）.           | 实现图形显示能力.                   | **P0(核心)** |
|                          | **输入抽象**     | 实现 `input_manager` 组件，将按键和摇杆抽象成**统一的逻辑输入接口**. | **输入统一**，解耦应用层.           | **P0(核心)** |
|                          | **架构验证**     | 实现一个**极简原型游戏**（如简化版贪吃蛇），验证"输入抽象 + 显示 + 游戏逻辑"能跑通. | 验证整体架构可行性.                 | **P0(核心)** |
| **II. 菜单框架与游戏扩展** | **菜单框架**     | 设计并实现**多级菜单框架**（主菜单 → 游戏菜单 → 设置菜单等层次结构）. | 完整的 UI 状态机与分层结构.         | **P0(核心)** |
|                          | **游戏重构**     | 将阶段I的原型游戏**重构为独立模块**，接入菜单框架.           | 验证游戏接入机制.                   | **P0(核心)** |
|                          | **游戏扩展**     | 添加2-3个新游戏（推箱子、俄罗斯方块等），验证框架扩展性.     | 验证框架的可扩展性.                 | **P0(核心)** |
|                          | **虚拟键盘**     | 实现虚拟键盘组件，支持字符输入（用于改名、输入分数等场景）.   | 字符输入能力.                       | **P1(重要)** |
| **III. 数据持久化**      | **存储底层**     | 实现 Flash 和 SD 卡文件管理功能（FatFs文件系统）.             | 文件系统和驱动程序就绪.             | **P1(重要)** |
|                          | **档案管理**     | 实现**玩家档案系统**（支持多个档案，每个档案包含昵称、头像、设置等）. | 多档案支持.                         | **P1(重要)** |
|                          | **游戏数据**     | 实现游戏排行榜和存档功能，数据存储到 SD 卡，支持断电保存.     | 数据持久化与档案隔离.               | **P1(重要)** |
| **IV. 高级外设**         | **时钟/日历**    | 实现万年历和实时时钟 (RTC) 功能.                             | 永久时间管理.                       | **P2(可选)** |
|                          | **实用工具**     | 实现计算器功能和其它工具菜单项.                              | 工具类应用扩展.                     | **P2(可选)** |
| **V. 网络与云同步（选做）** | **网络集成**     | 实现 Wi-Fi/以太网模块的底层驱动及 LwIP 协议栈移植.           | **网络连接**和**协议栈就绪**。      | **P3(选做)** |
|                          | **数据上传**     | 通过 HTTP/MQTT 协议上传玩家数据到云端服务器.                 | **云端数据备份**。                  | **P3(选做)** |
|                          | **云端同步**     | 实现排行榜分数、存档点的云端双向同步.                        | **多设备一致性**。                  | **P3(选做)** |
|                          | **时间校准**     | 通过 NTP 自动校准 RTC 时间.                                  | **时间精度**。                      | **P3(选做)** |
|                          | **天气服务**     | 调用开放 API 获取天气信息并显示.                             | **信息获取**。                      | **P3(选做)** |
| **VI. 蓝牙联机（选做）** | **蓝牙驱动**     | 引入蓝牙模块（HC-05/06 串口透传）的底层驱动和配置.            | **无线通信**硬件就绪。              | **P3(选做)** |
|                          | **通信协议**     | 设计并实现双机通信协议（数据打包、校验、同步机制）.           | **可靠数据传输**。                  | **P3(选做)** |
|                          | **联机对战**     | 实现两个游戏机的蓝牙对战功能（STM32 ↔ STM32），支持至少一款对战游戏. | **本地联机对战**。                  | **P3(选做)** |

【待补充】## ⏱️ 时间规划与里程碑
【说明】为每个阶段设定预期完成时间和里程碑，建议包括：

| 阶段 | 预计工期 | 里程碑事件 | 优先级 |
|------|---------|-----------|--------|
| 阶段I | 待定 | 原型游戏可运行，架构验证通过 | **P0(核心)** |
| 阶段II | 待定 | 菜单系统完成，3个游戏可玩 | **P0(核心)** |
| 阶段III | 待定 | 档案管理+存档+排行榜功能完成 | **P1(重要)** |
| 阶段IV | 待定 | 工具类功能完成 | **P2(可选)** |
| 阶段V | 待定 | 网络功能验证（选做） | **P3(选做)** |
| 阶段VI | 待定 | 蓝牙联机功能验证（选做） | **P3(选做)** |

**注意：**
- **MVP = 阶段I + 阶段II**，这是必须完成的核心功能
- 阶段III为重要但非必需功能，可根据学习进度选择实现
- 阶段IV/V/VI为高级扩展功能，属于锦上添花
- 每个阶段完成后进行代码review和架构验证
- 预留20%缓冲时间应对技术难题



## 🏗️ 非功能性要求 (Non-Functional Requirements - NFRs)

这些要求是代码设计和架构验证的**硬性标准**。

### 2.1 架构与模块化要求：三层解耦原则

项目代码必须严格遵循以下三层解耦架构，以确保**应用层**对底层硬件的依赖最小化：

| **层级**                        | **依赖关系**       | **设计约束**                                                 |
| ------------------------------- | ------------------ | ------------------------------------------------------------ |
| **L3: 应用层 (App)**            | 仅依赖 L2 抽象层。 | **绝不允许**直接调用任何 HAL 库函数（`HAL_...`）或直接操作寄存器。 |
| **L2: 驱动抽象层 (Components)** | 依赖 L1 驱动层。   | 提供统一的、与硬件无关的**组件接口**（如 `input_is_pressed()`），负责将 L3 请求转换为对 L1 的调用。 |
| **L1: 硬件驱动层 (Bsp)**        | 依赖 HAL 层。      | 包含 HAL 库调用、中断服务函数 (ISR) 和直接的硬件配置，只能被 L2 调用。 |

### 2.2 可扩展性要求：最小文件修改原则

为验证框架的解耦程度，设定以下标准：

- **新增一个菜单项：** 必须限制在**修改 2 个以内**的文件（通常为菜单定义文件和相应的回调函数文件）。
- **新增一个独立游戏：** 必须限制在**修改 3 个以内**的文件（通常为游戏逻辑文件、游戏注册文件、以及主菜单注册文件）。

### 2.3 性能要求：学习掌握优化方法 🚀

项目必须以实践为目标，完成以下性能优化任务：

1. **性能分析工具的实现：** 实现 **FPS 计数器**和**微秒级**函数执行时间测量工具。
2. **基准性能测量：** 使用当前的**事件驱动架构**（事件队列 + 调度器）实现第一个游戏，记录此时的**基准 FPS**。
3. **系统优化与验证：** 通过应用 **DMA**（用于 I2C 显示传输优化）等 HAL 高级特性来消除性能瓶颈。识别并优化热点函数。
4. **最终目标：** 测量优化后的帧率，并实现第一个游戏达到**稳定且肉眼可见流畅**的帧率（目标：持续高于 **30 FPS**）。

**性能优化学习重点：**
- 学习如何使用性能分析工具定位瓶颈
- 理解 DMA 在数据传输中的优势
- 掌握非阻塞设计对性能的影响
- 学会在资源受限环境下的优化策略

------

## 🗺️ 阶段划分与最小验收标准 (Acceptance Criteria - AC)

本项目分六个阶段实施，每个复杂模块必须满足其最小验收标准 (AC)。

### Stage I: 核心驱动与架构验证

| **模块**     | **核心功能目标**             | **最小验收标准 (AC)**                                        |
| ------------ | ---------------------------- | ------------------------------------------------------------ |
| **输入抽象** | **输入统一**，解耦应用层。   | `input_manager` 必须成功将 `ebtn` 和 `rocker` 事件**统一**并抽象为 `INPUT_ACTION_UP/DOWN/LEFT/RIGHT/CONFIRM` 等逻辑输入，且应用层**只能**通过 `input_is_pressed()` 等抽象接口获取输入。 |
| **架构验证** | 验证整体架构可行性。         | 实现一个**极简原型游戏**（如5x5网格的简化版贪吃蛇），游戏逻辑**完全**依赖 L2 层的 `input_manager` 和 `u8g2` API，**不直接调用任何 HAL 函数**。游戏能正常运行，响应输入，FPS > 20。 |

### Stage II: 菜单框架与游戏扩展

| **模块**     | **核心功能目标**             | **最小验收标准 (AC)**                                        |
| ------------ | ---------------------------- | ------------------------------------------------------------ |
| **菜单框架** | 完整的 UI 状态机与分层结构。 | 实现一个**多级菜单结构**（主菜单 → 游戏菜单 → 设置菜单 → 子菜单），并且在**新增菜单项**时，遵循**最小文件修改原则**（≤2个文件）。 |
| **游戏重构** | 验证游戏接入机制。           | 将阶段I的原型游戏**重构为独立模块**，成功接入菜单框架，能从菜单启动游戏并返回菜单。 |
| **游戏扩展** | 验证框架可扩展性。           | 添加至少**2个新游戏**（如推箱子、俄罗斯方块），新增游戏时符合**最小文件修改原则**（≤3个文件）。所有游戏能独立运行且互不影响。 |
| **虚拟键盘** | 字符输入能力。               | 实现虚拟键盘组件，支持通过按键/摇杆输入**字母、数字、基本符号**，能用于玩家改名、输入分数等场景。 |

### Stage III: 数据持久化系统

| **模块**                | **核心功能目标**         | **最小验收标准 (AC)**                                        |
| ----------------------- | ------------------------ | ------------------------------------------------------------ |
| **存储底层 (Flash/SD)** | 文件系统和驱动程序就绪。 | **SD 卡：** 成功使用 FatFs 创建文件，写入数据，**断电重启**后能成功读取相同数据。 **Flash：** 成功写入配置结构体到内部 Flash，**断电重启**后能成功读取。 |
| **档案管理**            | 多档案支持。             | 实现**玩家档案系统**，支持至少 **3个独立档案**，每个档案包含昵称、头像ID、游戏设置等。档案数据存储在 Flash，支持创建、切换、删除档案。断电重启后档案数据不丢失。 |
| **游戏数据**            | 数据持久化与档案隔离。   | 实现游戏**排行榜和存档功能**，每个档案的游戏数据**独立存储**（不同档案看到不同的排行榜和存档）。数据存储在 SD 卡，支持断电保存。至少支持1个游戏的排行榜（记录前10名）。 |

【待补充】### Stage IV: 高级外设系统

| **模块**       | **核心功能目标** | **最小验收标准 (AC)** |
| -------------- | ---------------- | --------------------- |
| **时钟/日历 (RTC)** | 待补充 | 建议：RTC断电后时间继续运行，误差<1分钟/天；能显示年月日时分秒；支持闹钟设置。 |
| **实用工具 (计算器)** | 待补充 | 建议：支持基本四则运算(+-×÷)；支持小数点运算；精度到小数点后2位；能通过按键输入数字和运算符。 |

### Stage V: 网络与云同步系统

| **模块**         | **核心功能目标**       | **最小验收标准 (AC)**                                        |
| ---------------- | ---------------------- | ------------------------------------------------------------ |
| **基础通信**     | 网络连接和协议栈就绪。 | 设备成功连接到 Wi-Fi/以太网，并能通过 **TCP 客户端**连接到一个公共 IP 地址。 |
| **用户数据上传** | 身份验证和安全传输。   | 成功通过 **HTTPS 或 MQTT** 协议，将一个硬编码的 JSON 字符串**发送到**一个预设的云服务，并收到服务器的 **HTTP 200/成功** 响应。 |
| **时间校准**     | 时间精度。             | 通过 **NTP** 成功获取网络时间，并将设备的 **RTC 时间**校准至网络时间的 $\pm 5$ 秒以内。 |

### Stage VI: 蓝牙联机系统（选做）

| **模块**       | **核心功能目标**   | **最小验收标准 (AC)**                                        |
| -------------- | ------------------ | ------------------------------------------------------------ |
| **蓝牙驱动**   | 无线通信硬件就绪。 | 成功初始化蓝牙模块（HC-05/06），实现主从机配对，能通过串口收发测试数据。 |
| **通信协议**   | 可靠数据传输。     | 设计并实现双机通信协议（数据帧格式、校验机制、ACK确认），能稳定传输游戏状态数据，丢包率<1%。 |
| **联机对战**   | 本地联机对战。     | 成功实现**至少一款游戏**的双机对战功能（如联机贪吃蛇、对战俄罗斯方块），两台设备能实时同步游戏状态，延迟<100ms。 |

------

【待补充】## ⚠️ 风险评估与应对策略

【说明】识别各阶段的技术风险和应对方案，建议按以下格式组织：

### 高风险项 🔴

| 风险点 | 所属阶段 | 风险描述 | 影响程度 | 应对策略 |
|--------|---------|---------|---------|---------|
| **待补充** | 阶段V | 例：Wi-Fi模块调试困难，LwIP协议栈移植复杂 | 可能导致阶段V无法完成 | 备选方案：先用串口模拟网络通信，验证上层逻辑；或选用带SDK的成熟Wi-Fi模块（如ESP8266/ESP32） |
| **待补充** | 阶段VI | 例：蓝牙通信不稳定，数据同步延迟高 | 可能影响联机对战体验 | 备选方案：优化通信协议，减少数据传输量；增加本地预测机制；降低帧同步频率 |

### 中风险项 🟡

| 风险点 | 所属阶段 | 风险描述 | 影响程度 | 应对策略 |
|--------|---------|---------|---------|---------|
| **待补充** | 阶段III | 例：内部Flash擦写次数有限，频繁写入导致损坏 | 影响数据持久化可靠性 | 实现磨损均衡算法；将高频数据移至SD卡 |
| **待补充** | 阶段I-II | 例：OLED刷新率不足，游戏卡顿 | 影响用户体验 | 使用DMA优化I2C传输；减少不必要的绘制操作；降低游戏复杂度 |

### 低风险项 🟢

| 风险点 | 所属阶段 | 风险描述 | 影响程度 | 应对策略 |
|--------|---------|---------|---------|---------|
| **待补充** | 阶段IV | 例：RTC时钟精度不够 | 轻微影响时钟功能 | 增加手动校准功能；后期通过NTP校准 |

### 资源风险 💾

| 风险点 | 风险描述 | 应对策略 |
|--------|---------|---------|
| **内存不足** | STM32F4内存有限，功能增多可能导致内存溢出 | 优化缓冲区大小；使用外部SRAM；精简功能模块 |
| **开发时间** | 部分阶段技术难度高，可能超出预期时间 | 预留20%缓冲时间；优先完成MVP；后期功能可选实现 |

------

**文档版本: v3.0 | 更新日期: 2025-12-06**

**v3.0 更新说明：**
- ✅ 明确阶段I和II的划分：先实现原型游戏验证架构，再实现菜单框架
- ✅ 优先级明确：P0(核心) / P1(重要) / P2(可选) / P3(选做)
- ✅ 用户管理改为玩家档案管理，简化复杂度
- ✅ 删除蓝牙HID手柄模式，仅保留联机对战功能
- ✅ 性能优化路径调整为基于现有事件驱动架构
- ✅ 阶段V/VI明确标记为选做功能
